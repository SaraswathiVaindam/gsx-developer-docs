{"version":3,"sources":["Typesense/RequestWithCache.js"],"names":["RequestWithCache","_responseCache","requestContext","requestFunction","requestFunctionArguments","cacheResponseForSeconds","call","requestFunctionArgumentsJSON","JSON","stringify","cacheEntry","Date","now","requestTimestamp","Promise","resolve","response"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;IAEqBA,gB;AACnB,8BAAe;AAAA;AACb,SAAKC,cAAL,GAAsB,EAAtB;AACD;;;;;6FAED,iBAAeC,cAAf,EAA+BC,eAA/B,EAAgDC,wBAAhD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,+EAA+G,EAA/G,+BAA2EC,uBAA3E,EAA2EA,uBAA3E,sCAAqG,IAAI,EAAzG;;AAAA,sBAEMA,uBAAuB,IAAI,CAFjC;AAAA;AAAA;AAAA;;AAAA,iDAGWF,eAAe,CAACG,IAAhB,OAAAH,eAAe,GAAMD,cAAN,0CAAyBE,wBAAzB,GAH1B;;AAAA;AAMQG,gBAAAA,4BANR,GAMuCC,IAAI,CAACC,SAAL,CAAeL,wBAAf,CANvC;AAOQM,gBAAAA,UAPR,GAOqB,KAAKT,cAAL,CAAoBM,4BAApB,CAPrB;;AAAA,qBAQMG,UARN;AAAA;AAAA;AAAA;;AAAA,sBASQC,IAAI,CAACC,GAAL,KAAaF,UAAU,CAACG,gBAAxB,GAA2CR,uBAAuB,GAAG,IAT7E;AAAA;AAAA;AAAA;;AAAA,iDAWaS,OAAO,CAACC,OAAR,CAAgBL,UAAU,CAACM,QAA3B,CAXb;;AAAA;AAaM;AACA,uBAAO,KAAKf,cAAL,CAAoBM,4BAApB,CAAP;;AAdN;AAAA;AAAA,uBAiByBJ,eAAe,CAACG,IAAhB,OAAAH,eAAe,GAAMD,cAAN,0CAAyBE,wBAAzB,GAjBxC;;AAAA;AAiBQY,gBAAAA,QAjBR;AAkBE,qBAAKf,cAAL,CAAoBM,4BAApB,IAAoD;AAClDM,kBAAAA,gBAAgB,EAAEF,IAAI,CAACC,GAAL,EADgC;AAElDI,kBAAAA,QAAQ,EAARA;AAFkD,iBAApD;AAlBF,iDAsBSA,QAtBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O","sourcesContent":["'use strict'\n\nexport default class RequestWithCache {\n  constructor () {\n    this._responseCache = {}\n  }\n\n  async perform (requestContext, requestFunction, requestFunctionArguments, {cacheResponseForSeconds = 2 * 60} = {}) {\n    // Don't store any responses if cache is disabled\n    if (cacheResponseForSeconds <= 0) {\n      return requestFunction.call(requestContext, ...requestFunctionArguments)\n    }\n\n    const requestFunctionArgumentsJSON = JSON.stringify(requestFunctionArguments)\n    const cacheEntry = this._responseCache[requestFunctionArgumentsJSON]\n    if (cacheEntry) {\n      if (Date.now() - cacheEntry.requestTimestamp < cacheResponseForSeconds * 1000) {\n        // Cache entry is still valid, return it\n        return Promise.resolve(cacheEntry.response)\n      } else {\n        // Cache entry has expired, so delete it explicitly\n        delete this._responseCache[requestFunctionArgumentsJSON]\n      }\n    }\n    const response = await requestFunction.call(requestContext, ...requestFunctionArguments)\n    this._responseCache[requestFunctionArgumentsJSON] = {\n      requestTimestamp: Date.now(),\n      response\n    }\n    return response\n  }\n}\n"],"file":"RequestWithCache.js"}